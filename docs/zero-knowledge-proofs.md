# Проекты на блокчейне на основе zero-knowledge протокола

## Zero-knowledge proof

zero-knowledge протокол это криптографический метод, где одна из сторон может доказать правдивость определенного утверждения не раскрывая при доказательстве информации, отличной от той, что утверждение истинно. 

### zk-SNARKS

SNARKS - это акроним к Succinct Non-Interactive ARguments of Knowledge. Протокол позволяет использовать относительно небольший доказательства без многократного взаимодествия сторон. 

Опуская техническую сторону, расмотрим протоколы с таким интерфейсом. Для данного вычислимого условия (схемы) `C(input, hidden)->bool` существуют функции `P(input, hidden)->any` и `V(proof, input)->bool`, что `V(P(input, hidden), input)`, если `C(input, hidden)`, и при `V(proof, input)` вероятность того, что `proof` получен не с помощью `P`, сколь угодно мала. При этом `proof` не даёт информации о `hidden`.

Также отметим, что для создания таких `V` и `P` должны быть случайно сгенерированы на основе `C` специальные ключи (которые будут общедоступны), и доступ к seed'у генерации с проверяющей стороны позволяет подделывать доказательства.

## Применения в блочейне

### Tornado cash

Миксер Tornado Cash - это миксер криптовалют, который использует zero-knowledge для анонимизации транзакций. 

#### Дополнительные технические детали

Tornado Cash использует [Merkle Tree](https://en.wikipedia.org/wiki/Merkle_tree "Википедия"). С помощью данной структуры можно эффективно хранить некоторые данные с возможностью верифицировать наличие определенного значения. Структура представляет из себя бинарное дерево, в листях которого хранятся хэши исходных данных $L_i$. На каждом следующем уровне выше поочередно для пар вершин прошлого уровня в вершинах сохраняются хэши конкатенаций значений в паре вершин прошлого уровня.

<image src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/95/Hash_Tree.svg/1280px-Hash_Tree.svg.png" alt="Структура дерева">

Таким образом, для доказательства наличия $L_i$ (точнее, его хэша) в структуре, достаточно построить путь от вершины с хэшем к корню и взять для каждой вершины пути (кроме самого корня) значение из парной вершины того же уровня. Тогда при последовательном вычислении хэшей вершин пути на основе хэша $L_i$ и далее вычислиние хэшей конкатенаций в конце должен получиться хэш корня. Для тех данных, которые не вносились в структуру как аргументы хэш-функции в листьях подбор доказательства вычислительно сложен, ведь как минимум последний элемент доказательств должен решать задачу обратного высиления аргумента хэша. 

----

Теперь перейдем к описанию смарт-контракта. Помимо технических аспктов параметром инициализации является число `denomination` - сумма, на которую можно переводить средства на контракт. Помимо этого контракт хранит в себе данные в структуре Merkle tree, сохраняющей все значения `root` по ходу работы, структуру для хранения использованных значений `commitment` и использованных значений `nullifierHash`.

 Контракт имеет функции `P`, `V` в описанном протоколе для такой схемы `C(input, hidden)`:

 - `input = (root, nullifierHash, recipient, relayer, fee, refund)`
 - `hidden = (nullifier, secret, pathElements, pathIndices)`
 - `C(input, hidden)=True` если `hash(nullifier) = nullifierHash` И `pathElements, pathIndices` являются массивами из хэшей и индексов вершин дерева, которые доказывают принадлежность `hash(secret, nullifier)` внутреннему Merkle tree (см выше) со значением в корне `root`.

#### `deposit`

Для депозита необходимо сгенерировать 2 случайных числа: `secret` и `nullifier` и сохранить их. После этого на контракт отправляется транзакция с методом `deposit` с платой эфира в размере `denomination`. Аргументом вызова будет одно значение: `commitment=hash(secret, nullifier)`. 

Контракт сохраняет `commitment` во внутреннем Merkle tree, если данное значение ещё не использовалось, иначе отклоняет транзакцию.

#### `withdraw`

Для анонимного вывода средств с помощью сохраненных `secret, nullifier` необходимо:

- вычислить `commitment=hash(secret, nullifier)`;
- получить информацию о Merkle Tree контракта, на основе построить доказательство из `pathElements, pathIndices` для `commitment`, сохранить значение `root`;
- `input=(root, hash(nillifier), recipient, relayer, fee, refund)`, где `(recipient, relayer, fee, refund)` - непосредственно параметры транзакции, не связанные с zk-SNARK, то есть адрес получателя эфира, адрес, осуществляющий оплату газа за комиссию для перевода и т.д.
- `hidden=(nullifier, secret, pathElements, pathIndices)` 
- `proof=P(input, hidden)`
- вызвать метод контракта `withdraw` с аргументами `proof, *input`

При таком вызове контракт проверяет, что `nullifierHash` ещё не был использован; `root` является историческим или текущим корнем дерева; `V(proof, input)`. Если всё выполнено, то происходит перевод средств на кошелёк `recipient` и комиссии на аккаунт `relayer`, `nullifierHash` омтмечается как использованный.

----
#### Теоретические утверждения

-   **Утверждение 1:** данный алгоритм позволяет получить средства по       корректным `sercet`, `nullifier`. 

    **Доказательсвто:** поскольку параметр `nullifierHash` вычисляется непосредственно как `hash(nullifier)`, а `pathElements, pathIndices` строятся как доказательство по правильному дереву для `commitment`, то `V` действительно подтвердит кореектность доказательства.

-   **Утверждение 2:** без ифнормации о `secret` или `nullifier`, использовавшихся в каком-либо прошлом вызове `deposit` для вычисление `commitment` подбор таковых для корректного заврешения транзакции вычислительно сложен.

    **Доказательство:** без этой информации нет информации о `commitment`, добавлялвшемся в Merkle Tree, для корректных значений `root` подобрать доказательство нельзя, некорректные не пройдут второй этап проверки. 

-   **Утверждение 3:** по данным `secret, nullifier` не получится получить получить средства дважды.

    **Доказательство:** если использовать в `input` значение `nullifierHash`, отличное от `hash(nullifier)`, то для корректности доказательства при его построении точно должно использоваться другое значение `nullifier`, что невозможно для получения средств в силу утверждения 2. Среди транзакций с одним и тем же значением `nullifierHash` средства может перевести лишь одна в силу первой проверки контракта при вызове `withdraw`.

-   **Утверждение 4:** при `withdraw` в момент $T$ по аргументам вызова невозможно определить, на на основе какого `commitment` из вызовов `deposit` до $T$ порожден текущий вызов.

    **Доказательство:** в вызове `withdraw` есть 4 аргумента, привязаны непосрдственно к транзакции, которые не зависят от остальных параметров. `root` - общий параметр текущего состояния контракта. `proof` не даёт информацию в силу использования zero-knowledge протокола, а `nulliferHash` является хэш-функцией от `nullifier`, когда `commitment` - от `(secret, nullifier)`, что для правильной хэш-функции независимо информационно.

Итого, по каждому вводу средств можно вывести с помощью секретных данных ровно единожды, при этом аргументы транзакций не позволяют связать пользователя, вызвавшего `deposit` и пользователя, вызвавшего `withdraw`. Остальная информация транзакции - `value` фиксирована в рамках контракта, адреса, вызвыающие контракт и получающие средства могут быть не связаны при грамотном испольщовании миксера - тоже не снимают анонимность с перевода средств.

----

#### Размышления

Для поиска контрактов в сети с похожей логикой работы хочется обратить внимание на ряд особенностей работы контракта в плане тразакций и того, как этот адрес выглядит в графе транзакций блокчейна.

- Если транзакция оплачивается, то на некоторую фиксированную сумму. У tornado существуют контракты-роутеры, которые делегируют выполнение той же логике для одной из сумм из ограниченного набора соответствующему контракту. Может быть внедрен механизм оплаты комиссии при депозите, однако суммы транзакций могут быть и в таком случае разделены на небольшое число групп, в рамках каждой сумма транзакций будет колебаться в небольшом дипазоне. 

- Все успешные вызовы контракта связаны с непосредственным переводом средств в сети. При любой транзакции происходит изменение балансов определенных адресов.

- Контракт работает только с эфиром. Ранее tornado предлагал контракты с такой же логикой для ERC-20 токенов, однако каждый контракт работал лишь с фиксированным токеном.

### Railgun

Платформа [Railgun](https://railgun.org/) позволяет анонимно переводить средства на ethereum с помощью zero-knowledge протокола. Аналогичным механизмом платформа предоставляет возможность создания анонимного адреса, перевода средств на него, перевода средств между анонимными адресами и вывод средств на реальный ethereum-аккаунт для ERC-20 и NFT токенов. Ограничений по сумме нет, что повышает риск деанонимизации при неаккуратном использовании сервиса. Как пример можно рассмотреть [эту](https://etherscan.io/tx/0xd6e7f2583d708dee750997f2b49c3420a8ad9cffccc617c019f060eab196f6ea) и [эту](https://etherscan.io/tx/0xd1efcb2decb637b9cf308a5caabb6171024b8f5ad39b36abc6c16366b05affa1) транзакции: можно предположить, что их инициатором был один пользователь. Идейно работа контракта строится на построении доказательств знания секрета, которые не дают информации об этом секрете.

### Zcash

[Zcash](https://z.cash/) предлагает свою сеть с транзакциями, использующие технологии zk-SNARK для перевода средств анонимно. Данные, предоставляемые при защищенной транзакции не разглашают информации о размере, отправителе, получателе. Конечно, размер таких транзакий превышает размер обычных, но остаётся достаточно небольшим благодаря технологиям zk-SNARK.  
